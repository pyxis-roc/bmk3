#!/usr/bin/python3
# -*- mode: python -*-

import argparse
import bmk3
import os
import sys
import bmk3.cmdscript as cmdscript
import logging
import glob
import fnmatch
import re
import textwrap
import bmk3.rulerunners as rulerunners

def find_bmk3():
    paths = ['.']

    while len(paths):
        try:
            with os.scandir(paths[0]) as l:
                for f in l:
                    if f.is_dir():
                        paths.append(f)
                    elif f.is_file() and f.name == 'bmk3.yaml':
                        yield f.path
        except PermissionError as e:
            logger.error(str(e))

        del paths[0]

def rule_globs_to_re(r):
    xp = [fnmatch.translate(rr) for rr in r]
    return re.compile("|".join([x for x in xp]))

def make_prefix_globs(r):
    # note that rules must be python identifiers, but suffixing with
    # variable contents can change this. So there is no way to detect
    # reliably that a rule prefix supplied on the command line
    # contains no globs. To prevent accidental globbing beyond prefix
    # expansion, we escape all glob characters.

    pg = [glob.escape(x) + "*" for x in r]

    return pg

logger = logging.getLogger('bmk3')

if __name__ == "__main__":
    p = argparse.ArgumentParser(description="Run a bmk3 script")
    p.add_argument("-g", dest="globrules", help="Treat rule prefixes as glob patterns",
                   action="store_true")
    p.add_argument("-v", dest="variables", help="Add variable", default=[], action="append")
    p.add_argument("-n", dest="dryrun", help="Dry run", action="store_true")
    p.add_argument("-q", dest="quiet", help="Quiet", action="store_true")
    p.add_argument("-k", dest="keep", choices=['always', 'fail', 'never'],
                   help="Keep temporary files", default='fail')
    p.add_argument("-C", dest="workdir", metavar="DIR", help="Change to DIR")
    p.add_argument("rules", nargs="*", help="Prefixes of rules to run", default=[])

    logging.basicConfig(level=logging.INFO)

    args = p.parse_args()
    if args.workdir:
        os.chdir(args.workdir)

    bmk3files = list(find_bmk3())
    cp = os.path.commonprefix(bmk3files)

    logger.info(f'Loaded {len(bmk3files)} files')
    logger.debug(f'Found {bmk3files}')

    if not len(bmk3files):
        logger.error(f"bmk3 configuration {os.getcwd()}/{args.bmk3file} does not exist.")
        sys.exit(1)

    cmdline_variables = {}
    if args.variables:
        for v in args.variables:
            vn, vv = v.split("=", 1)
            cmdline_variables[vn] = vv

    b = bmk3.BMK3()
    b.load_scripts(bmk3files, strip_prefix = cp)
    b.update_variables(cmdline_variables)
    b.expand_templates()

    if args.rules:
        if args.globrules:
            rule_re = rule_globs_to_re(args.rules)
        else:
            rule_re = rule_globs_to_re(make_prefix_globs(args.rules))
    else:
        rule_re = None

    # expand template definitions and build command scripts

    cmdscripts = []

    try:
        for s, t, g in b.generate():
            a, c = g
            k = [t]

            if 'binary' in a: k.append(a['binary'])
            if 'input' in a: k.append(str(a['input']['name']))

            name = ':'.join(k)

            if s.ns:
                name = f"{name}[{s.ns}]"

            if rule_re:
                if rule_re.match(name):
                    x = cmdscript.CmdScript(name, c, a, cwd = s.cwd)
                    cmdscripts.append(x)
            else:
                print(f"*** {name}")
                x = cmdscript.CmdScript(name, c, a)
                if not args.quiet:
                    print(textwrap.indent(str(x), '   '))
                x.cleanup()
    except KeyError as err:
        logger.error(f"While expanding template, {str(err)}")
        raise
        sys.exit(1)

    rr = rulerunners.SerialRunner()
    count, success = rr.run_all(cmdscripts, dry_run = args.dryrun, keep_temps = args.keep, quiet = args.quiet)
    if not args.dryrun:
        logger.info(f'COUNT: {count}, SUCCESS: {success}, FAILED: {count - success}')
    else:
        logger.info(f'COUNT: {count}')

