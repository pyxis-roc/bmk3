#!/usr/bin/python3
# -*- mode: python -*-

import argparse
import bmk3
import os
import sys
import bmk3.cmdscript as cmdscript
import logging
import datetime
import time
import glob
import fnmatch
import re
import textwrap

def find_bmk3():
    paths = ['.']

    while len(paths):
        with os.scandir(paths[0]) as l:
            for f in l:
                if f.is_dir():
                    paths.append(f)
                elif f.is_file() and f.name == 'bmk3.yaml':
                    yield f.path

        del paths[0]

def rule_globs_to_re(r):
    xp = [fnmatch.translate(rr) for rr in r]
    return re.compile("|".join([x for x in xp]))

logger = logging.getLogger('bmk3')

if __name__ == "__main__":
    p = argparse.ArgumentParser(description="Run a bmk3 script")
    #p.add_argument("-f", dest="bmk3file", help="bmk3 script file", default="bmk3.yaml")
    p.add_argument("-v", dest="variables", help="Add variable", default=[], action="append")
    p.add_argument("-n", dest="dryrun", help="Dry run", action="store_true")
    p.add_argument("-q", dest="quiet", help="Quiet", action="store_true")
    p.add_argument("-k", dest="keep", choices=['always', 'fail', 'never'],
                   help="Keep temporary files", default='fail')
    p.add_argument("-C", dest="workdir", metavar="DIR", help="Change to DIR")
    p.add_argument("rules", nargs="*", help="Rule globs to run", default=[])

    logging.basicConfig(level=logging.INFO)

    args = p.parse_args()
    if args.workdir:
        os.chdir(args.workdir)

    bmk3files = list(find_bmk3())
    logger.info(f'Loaded {len(bmk3files)} files')
    logger.debug(f'Found {bmk3files}')

    if not len(bmk3files):
        logger.error(f"bmk3 configuration {os.getcwd()}/{args.bmk3file} does not exist.")
        sys.exit(1)

    cmdline_variables = {}
    if args.variables:
        for v in args.variables:
            vn, vv = v.split("=", 1)
            cmdline_variables[vn] = vv

    b = bmk3.BMK3()
    b.load_scripts(bmk3files)
    b.update_variables(cmdline_variables)
    b.expand_templates()

    if args.rules:
        rule_re = rule_globs_to_re(args.rules)
    else:
        rule_re = None

    # expand template definitions and build command scripts

    cmdscripts = []

    try:
        for s, t, g in b.generate():
            a, c = g
            k = [t]

            if 'binary' in a: k.append(a['binary'])
            if 'input' in a: k.append(str(a['input']['name']))

            name = ':'.join(k)

            if rule_re:
                if rule_re.match(name):
                    x = cmdscript.CmdScript(name, c, a, cwd = s.cwd)
                    cmdscripts.append(x)
            else:
                print(f"*** {name}")
                x = cmdscript.CmdScript(name, c, a)
                if not args.quiet:
                    print(textwrap.indent(str(x), '   '))
                x.cleanup()
    except KeyError as err:
        logger.error(f"While expanding template, {str(err)}")
        raise
        sys.exit(1)

    count = 0
    success = 0

    for c in cmdscripts:
        logger.info(f"**** {c.name} from {c.cwd}")

        logger.info(textwrap.indent("\n" + str(c.script), '    '))
        count += 1
        fail = False
        if not args.dryrun:
            logger.info(f'Running {c.name} at {datetime.datetime.now()}')
            start = time.perf_counter()
            if not c.run():
                logger.error(f'Running {c.name} FAILED')
                if not args.quiet:
                    logger.info(c.result.output)
                    logger.info(c.result.errors)
                fail = True
            else:
                logger.error(f'Running {c.name} SUCCEEDED')
                if not args.quiet:
                    logger.info(c.result.output)
                    logger.info(c.result.errors)
                success += 1

            end = time.perf_counter()
            logger.info(f'{c.name} finished at {datetime.datetime.now()}')
            logger.info(f'{c.name} took {end - start} s')

        if args.keep != 'always':
            if args.keep == 'never' or not (fail and args.keep == 'fail'):
                c.cleanup()

    logger.info(f'COUNT: {count}, SUCCESS: {success}, FAILED: {count-success}')
